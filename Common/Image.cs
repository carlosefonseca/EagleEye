using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using System.Drawing;
using System.Drawing.Imaging;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System.Text.RegularExpressions;


namespace EagleEye.Common {
	[Serializable]
	public class Image : EEPersistable<Image> {
		// Remember to change the serialization when changing instance vars
		public long id = -1;
		public string path;
		public bool exifImported = false;
		public Dictionary<string, object> exif;
		private DateTime date;
		private string thumbnail;
		private Dictionary<string, string> pluginData = new Dictionary<string,string>();
		private bool dirty = false;

		public Image(string path) {
			this.path = Path.GetFullPath(path);
			exif = new Dictionary<string, object>();
			pluginData = new Dictionary<string, string>();
		}

		public override string ToString() {
			return "IMG ID " + this.id + " @ " + this.path + " - " + exif.Count + " EXIF items";
		}

		public void Exif(string k, string v) {
			try {
				exif.Add(k, v);
			} catch (ArgumentException) {
				exif[k] = v;
			}
		}

		public object Exif(string k) {
			try {
				return this.exif[k];
			} catch (KeyNotFoundException) {
				return "";
			}
		}

		public int Exif(Dictionary<string, object> exif) {
			this.exif = exif;
			return this.exif.Count;
		}

		public Dictionary<string, object> Exif() {
			return exif;
		}

		public string Details() {
			string txt = "";
			foreach (string k in exif.Keys) {
				txt += k.PadRight(30, ' ') + "   >   " + exif[k] + "\n";
			}
			return txt;
		}

		public DateTime Date() {
			if (date == null || date.Equals(new DateTime(0))) {
				String datetxt = null;
				if (exif.ContainsKey("DateCreated")) {
					Console.WriteLine(">> " + path + " > DateCreated");
					datetxt = exif["DateCreated"].ToString();
				} else if (exif.ContainsKey("CreateDate")) {
					Console.WriteLine(">> " + path + " > CreateDate");
					datetxt = exif["CreateDate"].ToString();
				} else if (exif.ContainsKey("FileModifyDate")) {
					Console.WriteLine(">> " + path + " > FileModifyDate");
					datetxt = exif["FileModifyDate"].ToString();
				} else {
					Console.WriteLine("!! No date found on EXIF :( for '" + this.path + "'");
				}
				if (datetxt != null) {
					if (DateTime.TryParse(datetxt, out date)) {
						Console.WriteLine(date);
						dirty = true;
						return date;
					} else {
						Match match = Regex.Match(datetxt, @"(\d{4}).(\d{2}).(\d{2}).(\d{2}).(\d{2}).(\d{2})", RegexOptions.IgnoreCase);
						if (match.Success) {
							String newTry = match.Groups[1] + "/" + match.Groups[2] + "-" + match.Groups[3] + " " + match.Groups[4] + ":" + match.Groups[5] + ":" + match.Groups[6];
							if (DateTime.TryParse(newTry, out date)) {
								Console.WriteLine(date);
								dirty = true;
								return date;
							} else {
								Console.WriteLine("!! Could not parse '" + datetxt + "' from '" + Path.GetFileNameWithoutExtension(this.path) + "'");
							}
						}
					}
				}
			}
			//Console.WriteLine(date);
			return date;
		}


		/// <summary>
		/// Checks if a certain EXIF key exists
		/// </summary>
		/// <param name="key">EXIF key</param>
		/// <returns>True if the key exists</returns>
		public bool ContainsExif(string key) {
			return exif.ContainsKey(key);
		}


		/// <summary>
		/// Tests if the Image has a thumbnail saved on disk.
		/// </summary>
		/// <returns>Path to thumbnail or null</returns>
		public string HasThumbnail() {
			if ((thumbnail != null) && (File.Exists(thumbnail))) {
				return thumbnail;
			}
			return null;
		}

		/// <summary>
		/// Attaches the plugin generated data to the image.
		/// </summary>
		/// <param name="pluginId">The unique plugin Id</param>
		/// <param name="data">A string representing the generated data</param>
		public void SetPluginData(string pluginId, string data) {
			pluginData.Add(pluginId, data);
			dirty = true;
		}

		/// <summary>
		/// Gets the data generated by all plugins for this image
		/// </summary>
		/// <returns>A Dictionary with [pluginID,data]</returns>
		public Dictionary<string, string> GetPluginData() {
			if (pluginData == null) {
				pluginData = new Dictionary<string, string>();
			}
			return pluginData;
		}
	
		/// <summary>
		/// Gets the data generated by a plugin for this image
		/// </summary>
		/// <param name="pluginId">The unique plugin Id</param>
		/// <returns>A string with the data</returns>
		public string GetPluginData(string pluginId) {
			return pluginData[pluginId];
		}

		/// <summary>
		/// Checks if a certain plugin has added data to this image
		/// </summary>
		/// <param name="pluginId">The unique plugin Id</param>
		/// <returns>True if the key exists</returns>
		public Boolean ContainsPluginData(string pluginId) {
			try {
				return pluginData.ContainsKey(pluginId);
			} catch (NullReferenceException e) {
				pluginData = new Dictionary<string, string>();
				return false;
			}
		}

		#region Serialization
		/* Constructor for use with data returned from a BDB get. */
		public Image(byte[] buffer) {
			/* Fill in the fields from the buffer. */
			BinaryFormatter formatter = new BinaryFormatter();
			MemoryStream memStream = new MemoryStream(buffer);
			Image tmp = (Image)formatter.Deserialize(memStream);

			this.id = tmp.id;
			this.path = tmp.path;
			this.exif = tmp.exif;
			this.pluginData = new Dictionary<string, string>();
			this.pluginData = tmp.pluginData;
			this.exifImported = tmp.exifImported;
			this.date = tmp.date;
			this.thumbnail = tmp.thumbnail;
			memStream.Close();
		}

		public Image Set(byte[] bytes) {
			return new Image(bytes);
		}

		/* 
		 * Marshall class data members into a single contiguous memory 
		 * location for the purpose of storing the data in a database.
		 */
		public byte[] GetBytes() {
			BinaryFormatter formatter = new BinaryFormatter();
			MemoryStream memStream = new MemoryStream();
			try {
				formatter.Serialize(memStream, this);
				byte[] bytes = memStream.GetBuffer();
				memStream.Close();
				return bytes;
			} catch {
				Console.WriteLine("A reformatar " + this.path);
				this.ReformatEXIF();
				try {
					formatter = new BinaryFormatter();
					memStream = new MemoryStream();
					formatter.Serialize(memStream, this);
					byte[] bytes = memStream.GetBuffer();
					memStream.Close();
					return bytes;
				} catch {
					Console.WriteLine("ERRO A SERIALIZAR " + this.path);
				}
			}
			return null;
		}

		private void ReformatEXIF() {
			Dictionary<string, object> itemsToChange = new Dictionary<string, object>();
			foreach (KeyValuePair<string,object> kv in exif) {
				string name = kv.Value.GetType().FullName;
				if (name.StartsWith("System.")) continue;
				switch (name) {
					case "Newtonsoft.Json.Linq.JArray":
						JArray jarr = (JArray)kv.Value;
						itemsToChange[kv.Key] = JsonConvert.DeserializeObject<List<Object>>(jarr.ToString());
						break;
					default: Console.WriteLine("Type " + name + " not implemented");
						break;
				}
			}
			foreach (KeyValuePair<string, object> kv in itemsToChange) {
				exif[kv.Key] = kv.Value;
			}
		}

		public byte[] Key() {
			return System.Text.Encoding.ASCII.GetBytes(this.id.ToString());
		}

		#endregion Serialization

		public string ToStringWithExif(string key) {
			return "Image " + this.id + " @ " + this.path + " - " + this.Exif(key);
		}

		/// <summary>
		/// Returns True if the object has been modified
		/// </summary>
		/// <returns>True if the object has been modified</returns>
		public Boolean Dirty() {
			return dirty;
		}

	}


	/// <summary>
	/// Compares two images by a certain EXIF key
	/// </summary>
	public class ImageExifComparer : IComparer<Image> {
		private string key;
		public ImageExifComparer(string key) {
			this.key = key;
		}

		public int Compare(Image x, Image y) {
			bool xok = x.ContainsExif(key);
			bool yok = y.ContainsExif(key);

			if (xok && yok)
				return x.Exif(key).ToString().CompareTo(y.Exif(key).ToString());
			else if (xok && !yok)
				return -1;
			else if (!xok && yok)
				return 1;
			else
				return 0;
		}
	}

	/// <summary>
	/// Compares two images by their Date
	/// </summary>
	public class ImageDateComparer : IComparer<Image> {
		public int Compare(Image x, Image y) {
			return x.Date().CompareTo(y.Date());
		}
	}

	/// <summary>
	/// Compares two images by their ID
	/// </summary>
	public class ImageIdComparer : IComparer<Image> {
		public int Compare(Image x, Image y) {
			return x.id.CompareTo(y.id);
		}
	}
}